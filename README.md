# observable
## ТЗ
### Разработать аналог javascript класса Observable
 Должен присутствовать основной механизм оповещение и подписок:
    1) Приннимать асинхронную очередь в конструктор 
    2) Иметь метод подписки - subscribe 
    3) Иметь метод отписки - unsubscribe 
    4) Иметь метод нотификации notify() 
    5) Thread-safe
    6) Работать асинхронно
    7) Не копируемый ()

### Почитать
C++: Логика подписки/нотификации реализованна в boost::signal2::signal; 
C++: Асинхронная очередь в boost::asio::io_context; 
C++: Лямбда-выражения
C++: Паттерн банды четырех (Observable)
C++: Некопируемые объекты - boost::noncopyable
С++: Умные указатели - std::shared_ptr | std::unique_ptr
C++: this как умный указатель - std::enable_shared_from_this
C++: функции как объекты или переменные std::function

## Пример использования

Предположим что у нас есть функция send которая работает асинхронно и результат выполнения будет известен в будущем. Эта функция возвращет Observable что позволит подписаться на результат и предпринять действия связанные с ним (не важно какие, главное возможность подписки).
пример на псевдокоде

Уровень 1 Junior | Pre-Midle
```Pseudo
send("Hello")->subscribe([](std::size_t sent_bytes){
    if (sent_bytes == 77) {
        std::cout << "Success send hello";
    }
});
```
Уровень 2 Midle | Pre-Sinior
```Pseudo
send("Hello")->subscribe([](std::size_t sent_bytes){
    if (sent_bytes == 77) {
        std::cout << "Success send hello";
    }
})->wait(); // Подписываемся и ожидаем пока не произайдет нотификация внутри функции send (пока не получим результат в одну из лямбд)
```

Уровень 3  Siniorito :)
```Pseudo
send("Hello")->subscribe([](std::size_t sent_bytes){
    if (sent_bytes == 77) {
        std::cout << "Success send hello";
    }
})->subscribe([](std::string error){
    std::cerr << "Fail send hello: " << error;
})->wait();
```



## Советую
Как лучше дествовать при разработки
Для уровня 0:
0) Разобраться с Observable в JS
1) Начать с написания API класса, что бы видеть к чему нужно прийти
2) Разобраться с возвратом себя (класса) через this-указатель
3) Разобраться с функциями и понять что они такие же как и обычные переменные (int | double | float и тд)
4) Разобраться с std::function
5) Посмотреть простейшие примеры шаблонных классов, структур и функций
Для уровня 1: 
6) Добавить к разработанному api boost::signal2::signal (уже какая никакая реализация ТЗ на половину)
7) Добавить шаблонность (template<typename T>)
Для уровня 2:
8) Разобраться с aсинхронной очередью
9) Внедрить ожидание (wait) нотификации
Для уровня 3:
10) Разобраться с std::variant
11) Внедрить вариативную подписку и нотификациюо
12) Сделать проверку типов 
